![](imgs/줄랭_한글배너.png)

한글 줄임말로 된 프로그래밍 언어 "줄랭" (줄임말 랭귀지)

줄랭은 간단한 문법으로 컴팩트하고 빠른 프로그램을 만들기 위해 고안된 언어입니다.  
C/C++과 비슷한 내부 구조를 가지지만, 정적 타입 추론을 적극 활용해 불필요한 명세를 줄여 생산성을 높였습니다.
LLVM을 기반으로 동작해 LLVM인프라스트럭처의 강력한 도구들을 활용할 수 있고, C/C++과 쉽게 링킹이 가능합니다.

**주의사항**:

- 줄랭은 알파 단계에 있습니다. 컴파일러에 대한 깊은 지식 없이 단기간에 개발되었고, 개발자도 알지 못하는 버그와 미스 컴파일링 가능성이 난무합니다.
- 굉장한 시간 부족으로 인해 지원하려고 했던 기능의 대부분을 아직 사용할 수 없습니다.
- 정확한 문법 지원 현황은 아래 [지원 현황](#문법-지원-현황) 에서 확인할 수 있습니다.

| 키워드 | 의미                |
|-----|-------------------|
| ㅎㅇ  | 구조체, 함수 정의        |
| ㄱㄱ  | 반복문 정의 (for)      |
| ㅇㅈ? | 조건문 정의 (if)       |
| ㄴㄴ? | 조건문 정의 (else if)  |
| ㄴㄴ  | 조건문 정의 (else)     |
| ㅈㅈ  | 함수 반환 (return)    |
| ㅅㄱ  | 반복문 정지 (break)    |
| ㅌㅌ  | 다음 반복 (continue)  |
| 입   | 표준 입력 함수 (scanf)  |
| 출   | 표준 출력 함수 (printf) |

| 타입 이름 | 의미      |
|-------|---------|
| 논리    | 1비트 정수  |
| 글자    | 8비트 정수  |
| 수     | 64비트 정수 |
| 실수    | 64비트 실수 |

### ㅎㅇ 키워드: (하이)

함수 또는 구조체를 정의할 때 사용하는 키워드입니다.   
아래처럼 ()를 사용하면 함수, 그렇지 않으면 구조체입니다.

- ㅎㅇ 함수이름():
- ㅎㅇ 구조체이름:

아래처럼 리턴 타입을 명시할 수 있습니다. 명시하지 않으면 기본적으로 void로 인식됩니다.

- ㅎㅇ 함수이름() 수:

함수 선언만 하고 싶다면 함수 프로토타입 끝에 콜론을 쓰지 않으면 됩니다.

- ㅎㅇ 함수이름() 글자
- ㅎㅇ 함수이름()

### ㄱㄱ 키워드: (고고)

반복문을 정의할 때 사용하는 키워드입니다.   
go언어의 for문처럼 다양한 형태로 사용 가능합니다.

- ㄱㄱ ㅂ = 1; ㅂ < 10; ㅂ+=1:   
  일반적인 반복문
- ㄱㄱ ㅂ < 10:   
  while문처럼 사용 가능
- ㄱㄱ :   
  아무것도 넣지 않으면 무한루프

### ㅇㅈ?, ㄴㄴ?, ㄴㄴ 키워드: (인정?, 노노?, 노노)

조건문을 정의할 때 사용하는 키워드입니다. 각각 if, else if, else에 대응합니다.

### ㅈㅈ, ㅅㄱ, ㅌㅌ 키워드: (GG, 수고, 튀튀)

ㅈㅈ는 return, ㅅㄱ는 break, ㅌㅌ는 continue의 의미를 가집니다.

### 입, 출 함수:

각각 C의 scanf, printf에 대응하는 함수입니다.

```
a = 10 (수)
b = 10.0 (실수)
c = 'a' (글자)
```

라고 가정하고 예시를 보여드리겠습니다.

입 함수는 `입(ㄱ, ㄴ, ㄷ)` 과 같은 형식으로 사용하고, 이는 `scanf("%ld %lf %c", &a, &b, &c)` 와 똑같이 작동합니다.   
줄랭 컴파일러가 정적 타입 추론 기능으로 포멧 문자열을 자동 생성하고, 실제 코드를 scanf 호출 구문으로 치환합니다.

출 함수도 비슷합니다. `출(ㄱ,ㄴ,ㄷ)` 을 사용하면, `printf("%ld %lf %c\n", a, b, c)` 로 변환됩니다.   
출력 형식이 파이썬의 print와 똑같습니다.

함수를 치환하고 포멧 문자열을 생성하는 동작은 모두 컴파일 타임에 일어나기 때문에, 런타임 오버헤드가 아예 없고, 실제 scanf, printf 함수를 사용하는 것과 성능이 똑같습니다.

만약 포멧 문자열을 지정하고 싶다면, 그냥 printf와 scanf를 직접 사용하면 됩니다.

### 변수 생성:

변수 생성은 3가지 방법으로 할 수 있습니다.

```
- ㄱ: 실수   
  자료형을 명시해서 '실수' 자료형이 되었고, 초기화는 되지 않음.
- ㄱ = 10   
  대입식을 가지고 타입이 자동 추론되어 '수' 자료형이 됨.
- ㄱ: 실수 = 10   
  자료형을 '실수'로 명시했기에, 대입식의 타입은 '수' 이지만 자동 캐스팅되어 10.0으로 초기화됨
```

**변수에 관한 설명 (중요):**

1. 다중 대입은 불가능합니다. 단순 '=' 뿐만 아니라, '+=', '/=' 등 대입 계열 연산자는 모두 한 구문에서 한 번만 사용할 수 있습니다.

2. 스코프 규칙은 C언어와 동일합니다. 함수, ㅇㅈ?문, ㄱㄱ문 등 블록이 생성되는 모든 곳에 지역 변수를 정의할 수 있고, 안쪽 스코프에서는 바깥쪽 스코프의 변수에 접근할 수 있습니다. 하지만 바깥 스코프에서는
   안쪽 스코프의 변수에 접근할 수 없습니다.

3. 줄랭은 변수 생성문과 대입문의 구문이 완전히 같기 때문에, 이를 구분할 수 없습니다. 따라서 줄랭 컴파일러는 이미 존재하는 변수면 대입문, 존재하지 않는 변수면 생성문으로 추론합니다.   
   이는 곧 외부 스코프에서 선언된 변수와 같은 이름을 가지는 변수를 생성할 수 없다는 것을 의미합니다.   
   "ㄱ: 실수" 또는 "ㄱ: 실수 = 10" 처럼 타입을 명시하는 변수 생성 방식은 생성인지 대입인지 명확히 추론할 수 있지만, 일관성을 위해 위와 같은 방식으로 동작합니다.   
   다만 반대로 어떤 내부 스코프에 정의된 변수가 있을 때, 외부에서는 해당 변수에 접근할 수 없기 때문에 외부에서는 똑같은 이름을 가지는 변수를 생성할 수 있습니다.

## 코드 예시:

줄랭으로 구현한 퀵 정렬 알고리즘입니다.

``` 

ㅎㅇ clock() 수
ㅎㅇ rand() 수

배열크기 = 10000000
배열: 수[10000000]

ㅎㅇ swap(ㄱ: 수, ㄴ: 수):
    임시 = 배열[ㄱ]
    배열[ㄱ] = 배열[ㄴ]
    배열[ㄴ] = 임시

ㅎㅇ 파티셔닝(피봇: 수, 왼쪽: 수, 오른쪽: 수) 수:
    ㄱㄱ :
        ㄱㄱ :
            왼쪽 += 1
            ㅇㅈ? 배열[왼쪽] >= 배열[피봇]:
                ㅅㄱ
        ㄱㄱ :
            오른쪽 -= 1
            ㅇㅈ? 배열[오른쪽] <= 배열[피봇]:
                ㅅㄱ
        ㅇㅈ? 오른쪽 <= 왼쪽:
            swap(오른쪽, 피봇)
            ㅈㅈ 오른쪽
        swap(오른쪽, 왼쪽)


ㅎㅇ 퀵정렬(시작: 수, 끝: 수) :
    ㅇㅈ? (시작 + 1 >= 끝) :
        ㅈㅈ

    피봇 = 파티셔닝(시작, 시작, 끝)

    퀵정렬(시작, 피봇)
    퀵정렬(피봇 + 1, 끝)

ㅎㅇ 시작() 수:
    ㄱㄱ 번호 = 0; 번호 < 배열크기; 번호 += 1:
        배열[번호] = rand()

    시작시간 = clock()

    퀵정렬(0, 배열크기)

    종료시간 = clock()

    ㄱㄱ 번호 = 0; 번호 < 배열크기; 번호 += 1:
        출(배열[번호])

    출((종료시간 - 시작시간), "ms")
```

## 현재 문제:

**윈도우 cp949 지원 문제**

윈도우 cmd의 한글 인코딩(cp949)과 일반적인 파일 인코딩(utf8)이 맞지 않아
파일 경로 탐색, 에러 메시지 출력, 구문 분석 등의 인코딩이 모두 다른 문제가 있습니다.

*줄랭 컴파일러는 모든 인코딩을 utf-8로 강제합니다.*

따라서 실행 전에 터미널에서 "chcp 65001" 을 실행해 터미널 인코딩을 utf-8로 바꿔주어야 합니다. 또는 윈도우 시스템 로켈을 utf8로 설정해 인코딩을 utf8로 통일해주어야지 정상적으로 작동합니다.

**함수 리턴 타입 추론 문제**

줄랭 컴파일러는 컴파일 속도를 위해 무조건 단방향 전진만 하도록 구현되어 있습니다. 
이 때문에 함수 리턴 타입 추론처럼 미리 앞의 내용을 보고 와야 하는 경우엔 파싱이 불가능합니다.

이를 해결할 방법을 고안 중이며, 클래스 같은 경우 단방향 파싱이 절대로 불가능하기 때문에, 
클래스가 추가될 때 같이 추가될 에정입니다.

**배열 및 포인터 문제**

줄랭 컴파일러의 타입 시스템은 굉장히 단순하게 이루어져 있고, 구조상 배열과 포인터를 처리하기가 매우 어렵습니다. 
또한 원시 포인터를 그대로 도입하지 않고, 포인터를 안전하게 사용할 수 있는 도구들을 추가하려 하기 때문에, 배열 및 포인터에 대한 지원은 꽤 오랜 시간 후에 가능할 것 같습니다.

타입 시스템이 대규모 개편되기 전까지 배열은 정적으로, 전역 변수로만 생성할 수 있습니다.

## 줄랭 컴파일러

줄랭은 LLVM을 기반으로 동작하고, 줄랭 컴파일러는 LLVM C++ API를 사용하여 만들어졌습니다. 이 레포지토리에 있는 컴파일러는 줄랭을 LLVM IR코드로(zul to ll) 변환하는 컴파일러 프론트엔드입니다.
따라서 네이티브 컴파일을 하기 위해선 추가적인 LLVM 도구들이 필요합니다.

줄랭 컴파일러는 JIT기능을 내장하고 있어 코드를 즉시 실행할 수 있습니다. 대부분의 경우에 이 기능으로 실행하길 권장합니다.

만약 바이너리 실행 파일을 얻고 싶다면 줄랭 컴파일러에 적절한 옵션을 넣어 IR 코드를 얻고, 이를 clang에 넣으면 됩니다. llc, lld 등을 이용하는 방법이 있지만, clang을 이용하는 것이 가장 편리합니다.

컴파일러 옵션은 아래와 같습니다.

- zul [옵션] <줄랭 소스파일>


- --help : 커맨드 라인 옵션 도움말
- -S : IR코드로 컴파일 (.ll 파일로 컴파일)
- -c : bitcode로 컴파일 (.bc로 컴파일)
- -o : 아웃풋 파일 이름 (-S 또는 -c 옵션을 주었을 때)

컴파일러의 자세한 동작 원리와 구조는 [컴파일러 구조](./컴파일러_구조.md) 를 참고하세요

## 문법 지원 현황

| 문법                    | 상태          |
|-----------------------|-------------|
| 산술 연산                 | 지원          |
| 논리 연산                 | 지원          |
| 지역 변수                 | 지원          |
| 전역 변수                 | 지원          |
| 단락 평가 (short-circuit) | 지원          |
| ㅈㅈ문                   | 지원          |
| ㄱㄱ문                   | 지원          |
| ㅌㅌ문                   | 지원          |
| ㅅㄱ문                   | 지원          |
| ㅇㅈ문                   | 지원          |
| 전역 변수 초기화             | 지원          |
| 암시적 형변환               | 지원          |
| 명시적 형변환               | 지원 예정       |
| 함수                    | 지원          |
| 함수 반환 타입 추론           | 지원 예정       |
| 배열                    | 지원 (전역 변수만) |
| 함수 오버로딩               | 지원 예정       |
| 연산자 오버로딩              | 지원 예정       |
| 참조자                   | 지원 예정       |
| 포인터                   | 미정          |
| 클래스                   | 지원 예정       |
| 동적 할당                 | 미정          |
| 삼항 연산자                | 미정          |
| static, const         | 미정          |
| 리터럴 배열                | 지원 예정       |
| 리터럴 셋                 | 지원 예정       |
| 리터럴 맵                 | 지원 예정       |
