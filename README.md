The Zul Programming Language
=

![](imgs/줄랭_한글배너.png)

한글 줄임말로 된 프로그래밍 언어 "줄랭" (줄임말 랭귀지)

줄랭은 간단한 문법으로 컴팩트하고 빠른 프로그램을 만들기 위해 고안된 언어입니다.  
C/C++과 비슷한 내부 구조를 가지지만, 정적 타입 추론을 적극 활용해 불필요한 명세를 줄여 더 빠르고 편하게 코드를 작성할 수 있습니다.   
LLVM을 기반으로 동작해 LLVM Infrastructure의 강력한 도구들을 활용할 수 있고, C/C++과 쉽게 링킹이 가능합니다.

**주의사항**:

- **반드시 터미널 인코딩을 UTF-8로 설정하고 실행해야 합니다. 아래 [알려진 문제](#알려진-문제)를 참고하세요**
- 줄랭은 알파 단계에 있습니다. 컴파일러에 대한 깊은 지식 없이 단기간에 개발되었고, 개발자도 알지 못하는 버그와 미스 컴파일링 가능성이 난무합니다.
- 이름 맹글링과 함수 오버로딩이 구현되지 않아서 아직 C++과는 링킹할 수 없습니다.
- 정확한 문법 지원 현황은 아래 [지원 현황](#문법-지원-현황) 에서 확인할 수 있습니다.

## 목차

1. [시작하기](#시작하기)
2. [줄랭의 문법](#줄랭의-문법)
   1. [ㅎㅇ 키워드](#ㅎㅇ-키워드-하이)
   2. [ㄱㄱ 키워드](#ㄱㄱ-키워드-고고)
   3. [ㅇㅈ?, ㄴㄴ?, ㄴㄴ 키워드](#ㅇㅈ-ㄴㄴ-ㄴㄴ-키워드-인정-노노-노노)
   4. [ㅈㅈ, ㅅㄱ, ㅌㅌ 키워드](#ㅈㅈ-ㅅㄱ-ㅌㅌ-키워드-gg-수고-튀튀)
   5. [입, 출 함수](#입-출-함수)
   6. [변수 생성](#변수-생성)
   7. [리터럴](#리터럴)
   8. [블록](#블록)
   9. [연산자](#연산자)
   10. [작명](#작명)
   11. [프로그램 진입점](#프로그램-진입점)
   
3. [코드 예시](#코드-예시)
4. [알려진 문제](#알려진-문제)
5. [줄랭 컴파일러](#줄랭-컴파일러)
6. [문법 지원 현황](#문법-지원-현황)
7. [참고 자료](#참고-자료)

## 시작하기

빌드된 줄랭 컴파일러는 [다운로드 페이지](https://github.com/zihasoo/Zul-lang/releases) 를 참고하세요.

줄랭 컴파일러의 코드를 수정하고, 빌드하고 싶다면 LLVM을 설치해야 합니다.

LLVM을 사용하기 위해선 LLVM 소스코드를 직접 빌드해야 하기 때문에,
cmake, ninja 또는 make 등의 빌드 시스템, C/C++ 컴파일러가 필요합니다.

자세한 내용은 [줄랭 세팅 방법](./zullang_TMI.md#줄랭-세팅-방법)을 참고하세요.

## 줄랭의 문법

| 키워드 | 의미                |
|-----|-------------------|
| ㅎㅇ  | 구조체, 함수 정의        |
| ㄱㄱ  | 반복문 정의 (for)      |
| ㅇㅈ? | 조건문 정의 (if)       |
| ㄴㄴ? | 조건문 정의 (else if)  |
| ㄴㄴ  | 조건문 정의 (else)     |
| ㅈㅈ  | 함수 반환 (return)    |
| ㅅㄱ  | 반복문 정지 (break)    |
| ㅌㅌ  | 다음 반복 (continue)  |
| 입   | 표준 입력 함수 (scanf)  |
| 출   | 표준 출력 함수 (printf) |

| 타입 이름 | 의미      |
|-------|---------|
| 논리    | 1비트 정수  |
| 글자    | 8비트 정수  |
| 수     | 64비트 정수 |
| 실수    | 64비트 실수 |

### ㅎㅇ 키워드: (하이)

함수 또는 구조체를 정의할 때 사용하는 키워드입니다.   
아래처럼 ()를 사용하면 함수, 그렇지 않으면 구조체입니다.

- `ㅎㅇ 함수이름():`
- `ㅎㅇ 구조체이름:`

아래처럼 리턴 타입을 명시할 수 있습니다. 명시하지 않으면 기본적으로 void로 인식됩니다.

- `ㅎㅇ 함수이름() 수:`

함수 선언만 하고 싶다면 함수 프로토타입 끝에 콜론을 쓰지 않으면 됩니다.

- `ㅎㅇ 함수이름() 글자`
- `ㅎㅇ 함수이름()`

함수 프로토타입을 선언할 때 매개변수 이름을 생략하고 타입만 나열할 수 있습니다.

- `ㅎㅇ 함수이름(실수, 실수, 글자)`

`...` 을 사용하면 가변 인자를 받는 함수를 선언할 수 있습니다. 하지만 va_arg 등의 지원이 없기 때문에 가변 인자를 사용할 순 없습니다.
외부 라이브러리 함수 선언용으로 존재합니다.

- `ㅎㅇ 함수이름(수, ...) 수`

### ㄱㄱ 키워드: (고고)

반복문을 정의할 때 사용하는 키워드입니다.   
go언어의 for문처럼 다양한 형태로 사용 가능합니다.

- `ㄱㄱ a = 1; a < 10; a+=1:`   
  일반적인 반복문
- `ㄱㄱ a < 10:`   
  while문처럼 사용 가능
- `ㄱㄱ :`   
  아무것도 넣지 않으면 무한루프

### ㅇㅈ?, ㄴㄴ?, ㄴㄴ 키워드: (인정?, 노노?, 노노)

조건문을 정의할 때 사용하는 키워드입니다. 각각 if, else if, else에 대응합니다. 아래와 같은 형태로 사용할 수 있습니다.

- `ㅇㅈ? <조건>:`
- `ㄴㄴ? <조건>:` (`ㄴㄴ?` 는 여러 개 가능)
- `ㄴㄴ :`

### ㅈㅈ, ㅅㄱ, ㅌㅌ 키워드: (GG, 수고, 튀튀)

ㅈㅈ는 return, ㅅㄱ는 break, ㅌㅌ는 continue의 의미를 가집니다.

### 입, 출 함수:

각각 C의 scanf, printf에 대응하는 함수입니다.

```
a = 10 (수)
b = 10.0 (실수)
c = 'a' (글자)
```

변수는 위처럼 정의되었다고 가정하겠습니다.

입 함수는 `입(a,b,c)` 과 같은 형식으로 사용하고, 이는 `scanf("%lld %lf %c", &a, &b, &c)` 와 똑같이 작동합니다.   
줄랭 컴파일러가 정적 타입 추론 기능으로 포멧 문자열을 자동 생성하고, 실제 코드를 scanf 호출 구문으로 치환합니다.   
따라서 `입(a)`도 가능하고, `입(a,b,c,d,e, .....)` 처럼 인자를 계속 넣을 수 있습니다.

출 함수도 비슷합니다. `출(a,b,c)` 을 사용하면, `printf("%lld %lf %c\n", a, b, c)` 로 변환됩니다.   
`출()`처럼 아무것도 넣지 않으면 `printf("\n")`로 추론되기 때문에, 빈 줄만 출력됩니다.   
원리는 완전히 다르지만 파이썬의 print와 거의 똑같이 작동한다고 보시면 됩니다.

함수를 치환하고 포멧 문자열을 생성하는 동작은 모두 컴파일 타임에 일어나기 때문에, 런타임 오버헤드가 전혀 없고, 실제 scanf, printf 함수를 사용하는 것과 성능이 똑같습니다.

만약 포멧 문자열을 바꾸고 싶다면, 그냥 printf와 scanf를 직접 사용하면 됩니다. 함수 테이블에 기본으로 존재하기 때문에 선언할 필요가 없습니다.

배열은 기본적으로 %p로 추론되고, '글자' 배열만 예외적으로 %s로 지정되어 있습니다.

### 변수 생성:

변수 생성은 3가지 방법으로 할 수 있습니다.

- `a: 실수`   
  자료형을 명시해서 '실수' 자료형이 되었고, 초기화는 되지 않음.
- `a = 10`   
  대입식을 가지고 타입이 자동 추론되어 '수' 자료형이 됨.
- `a: 실수 = 10`   
  자료형을 '실수'로 명시했기에, 대입식의 타입은 '수' 이지만 자동 캐스팅되어 10.0으로 초기화됨

전역 공간에서 선언과 동시에 초기화를 할 경우, 대입식은 반드시 상수식이어야 합니다. 현재 줄랭에는 상수 선언이 없기 때문에, 
리터럴 자체와 리터럴들의 연산식만 상수로 취급됩니다.

**배열**

배열과 포인터는 아직 완벽하게 지원되지 않습니다. 오로지 전역 공간의 1차원 배열만 지원합니다. 리터럴 배열 역시 지원되지 않습니다.   
아래와 같이 사용할 수 있습니다.

- `배열1: 수[100]`
- `배열2: 글자[50]`

**변수에 관한 설명 (중요)**

1. 다중 대입은 불가능합니다. 단순 `=` 뿐만 아니라, `+=`, `/=` 등 대입 계열 연산자는 모두 한 구문에서 한 번만 사용할 수 있습니다.


2. 스코프 규칙은 C언어와 동일합니다. `함수`, `ㅇㅈ?문`, `ㄱㄱ문` 등 블록이 생성되는 모든 곳에 지역 변수를 정의할 수 있습니다.
   또한 안쪽 스코프에서는 바깥쪽 변수에 접근이 가능하고, 바깥쪽에서는 안쪽 스코프에 정의된 변수에 접근할 수 없습니다.


3. 줄랭은 변수 생성과 대입의 문법이 완전히 똑같기 때문에, 이를 구분할 수 없습니다. 따라서 줄랭 컴파일러는 이미 존재하는 변수면 대입문, 존재하지 않는 변수면 생성문으로 추론합니다.


4. 위의 이유로 외부 스코프의 변수와 같은 이름을 가지는 변수를 생성할 수 없습니다. 항상 대입으로 추론됩니다.    
   `ㄱ: 실수` 또는 `ㄱ: 실수 = 10` 처럼 타입을 명시하는 변수 생성 방식은 생성으로 명확히 추론할 수 있지만, 일관성을 위해 생성하지 못하게 되어 있습니다.   
   (모든 변수가 스코프를 공유한다는 의미가 아닙니다. 외부 스코프 변수를 덮어쓰는 지역 변수를 생성할 수 없다는 의미입니다.)


5. 줄랭에는 함수 포인터나 함수를 객체처럼 취급하는 기능이 아예 없기 때문에, 함수와 변수의 이름 테이블이 완전히 분리되어 있습니다.
   따라서 함수의 이름과 똑같은 변수를 만들어도 됩니다. 호출 구문 '()' 이 사용되면 함수가 호출되고, 이외에는 모두 변수로 판단합니다.

### 리터럴

줄랭의 리터럴은 5가지가 있습니다.

1. 논리 리터럴 `참`, `거짓`:   
   1비트 정수인 `논리` 자료형의 리터럴입니다. 이름 그대로 각각 true, false에 해당합니다.   
   `참` 과 `거짓` 은 리터럴로 사용되기 때문에 변수명으로 사용할 수 없습니다.


2. 글자 리터럴:   
   C언어의 char와 같습니다 작은따옴표를 사용하고, 1바이트를 초과할 수 없습니다. `a = 'x'` 처럼 사용하면 됩니다.      
   아직 글자 리터럴에서 이스케이프 문자는 지원되지 않습니다. 곧 추가될 예정입니다.


3. 수 리터럴:   
    수 리터럴은 일반적인 숫자입니다. `a = 10` 처럼 사용하면 됩니다.


4. 실수 리터럴:  
    수 리터럴과 비슷하나, 소숫점이 포함되어 있으면 `실수`로 추론됩니다. 소숫점은 반드시 하나만 있어야 하고, 
    소숫점 앞 또는 뒤에만 숫자가 있어도 됩니다.


5. 문자열 리터럴:   
    C언어의 문자열 리터럴과 비슷합니다. 큰따옴표를 사용해 정의하고, 프로그램에 글로벌 스트링으로 저장됩니다.   
    `a = "안녕"`처럼 사용하면 됩니다. 유일하게 `\n`은 이스케이프 문자로 인식해서, 줄바꿈 문자로 사용할 수 있습니다.

### 블록

줄랭의 블록은 파이썬과 동일하게 들여쓰기로 구분됩니다. 하지만 탭 문자는 허용하지 않습니다.
오로지 공백 문자 4개만 하나의 들여쓰기로 인식합니다.

간단한 블록 예시를 보여드리겠습니다.

```
ㅎㅇ 시작() 수:
    출("함수 블록 시작입니다")

    ㄱㄱ :
        출("ㄱㄱ 블록 시작입니다")
        
        ㅇㅈ? 참:
            출("ㅇㅈ? 블록입니다")
            ㅅㄱ
        
        출("ㄱㄱ 블록 끝입니다")
        
    출("함수 블록 끝입니다")
```

실행 결과:

```
함수 블록 시작입니다
ㄱㄱ 블록 시작입니다
ㅇㅈ? 블록입니다
함수 블록 끝입니다
```

들여쓰기 횟수로 블럭이 구분되는 모습을 볼 수 있습니다. 

`ㅇㅈ?`문에서 `ㅅㄱ`로 `ㄱㄱ`문을 종료했기 때문에 "ㄱㄱ 블록 끝입니다" 는 출력되지 않았고, 
"함수 블록 끝입니다" 는 잘 출력되었습니다.

### 연산자:

구조체, 포인터에 관련된 연산자를 제외하고 C언어에 존재하는 모든 연산자를 사용할 수 있습니다.  
아래 연산자 우선순위 표를 확인하세요.

<details>
<summary> <b>연산자 우선순위 표</b> </summary>

| 연산자 종류 | 우선순위 그룹 번호 | 이름                              |
|--------|------------|---------------------------------|
| `~`    | 1          | one's complement                |
| `!`    | 1          | logical not                     |
| `-`    | 1          | unary negation                  |
| `+`    | 1          | unary plus                      |
| `*`    | 2          | multiplication                  |
| `/`    | 2          | division                        |
| `%`    | 2          | modulus                         |
| `+`    | 3          | addition                        |
| `-`    | 3          | subtraction                     |
| `<<`   | 4          | left shift                      |
| `>>`   | 4          | right shift                     |
| `<`    | 5          | less than                       |
| `>`    | 5          | greater than                    |
| `<=`   | 5          | less than equal to              |
| `>=`   | 5          | greater than equal to           |
| `==`   | 6          | equality                        |
| `!=`   | 6          | inequality                      |
| `&`    | 7          | bitwise AND                     |
| `^`    | 8          | bitwise exclusive OR            |
| `\|`   | 9          | bitwise inclusive OR            |
| `&&`   | 10         | logical AND                     |
| `\|\|` | 11         | logical OR                      |
| `=`    | 12         | assignment                      |
| `*=`   | 12         | multiplication assignment       |
| `/=`   | 12         | division assignment             |
| `%=`   | 12         | modulus assignment              |
| `+=`   | 12         | addition assignment             |
| `-=`   | 12         | subtraction assignment          |
| `<<=`  | 12         | left-shift assignment           |
| `>>=`  | 12         | right-shift assignment          |
| `&=`   | 12         | bitwise AND assignment          |
| `\|=`  | 12         | bitwise inclusive OR assignment |
| `^=`   | 12         | bitwise exclusive OR assignment |

</details>



`&&` 연산자와 `||` 연산자는 단락 평가를 지원합니다. 즉, `&&` 연산자는 앞의 표현식이 거짓이면, 뒤의 표현식은 평가하지 않습니다.   
마찬가지로 `||`연산자는 앞의 표현식이 참이면, 뒤의 표현식은 평가하지 않습니다.

### 작명:

함수 이름, 변수 이름 등의 작명 규칙은 C언어와 거의 동일합니다. 한글, 알파벳, 언더바, 숫자를 사용할 수 있고, 숫자로 시작할 순 없습니다.
또한 알파벳 대소문자를 구분합니다.

한가지 유의 사항은 하나의 이름에 한글과 영어를 섞어서 작명을 할 수 없습니다. 즉 (한글, 언더바, 숫자) 또는 (영어, 언더바, 숫자)만 가능합니다.

한글로 인식하는 유니코드 범위는 아래와 같습니다.

| 이름	                                    | 처음    | 	끝	   | 개수    |
|----------------------------------------|-------|-------|-------|
| 한글 자모 (Hangul Jamo)	                   | 1100	 | 11FF	 | 256   |
| 호환용 한글 자모 (Hangul Compatibility Jamo)	 | 3130	 | 318F	 | 96    |
| 한글 자모 확장 A (Hangul Jamo Extended A)	   | A960	 | A97F	 | 32    |
| 한글 소리 마디 (Hangul Syllables)	           | AC00	 | D7AF	 | 11184 |
| 한글 자모 확장 B (Hangul Jamo Extended B)	   | D7B0	 | D7FF	 | 80    |

해당 범위는 [Naver D2 한글 인코딩의 이해 2편](https://d2.naver.com/helloworld/76650?source=post_page---------------------------)
을 참고했습니다.

### 프로그램 진입점:

줄랭으로 만든 프로그램의 기본 진입점은 '시작' 함수입니다. 이 함수는 반드시 리턴 타입이 '수' 여야 하고, 매개 변수는 아무 의미가 없습니다.
추후에 포인터와 배열을 제대로 지원하게 되면 프로그램 인수를 받을 수 있도록 수정될 것입니다.

IR코드 또는 비트코드 파일로 컴파일하는 경우에는 C언어와의 호환성을 위해 '시작' 함수의 이름을
main으로 바꾸는 것으로 진입점을 설정합니다.

이미 main이라는 이름을 가진 함수가 있다면, 그 함수의 이름을 다른 것으로 바꿔버리기 때문에 충돌이 나진 않습니다. 하지만 main이라는
이름을 가진 함수를 정의하는 것은 별로 권장되는 행위는 아닙니다.

추가로 C언어의 main함수가 그러하듯, 시작 함수는 반환 구문을 작성하지 않아도 자동으로 0을 반환하는 구문이 삽입됩니다.

## 코드 예시:

줄랭으로 구현한 퀵 정렬 알고리즘입니다. 기본적으로 C라이브러리와 링킹이 되기 때문에,
아래의 clock과 rand처럼 선언만 해준다면 C언어의 함수를 쉽게 사용할 수 있습니다.

줄랭의 주석은 //를 사용합니다. 다른 언어와 비슷한 줄 주석으로, //부터 줄 끝까지가 무시됩니다.

``` 

ㅎㅇ clock() 수
ㅎㅇ rand() 수

//정수 1천만개 정렬 시간: 672ms
배열크기 = 10000000
배열: 수[10000000]

ㅎㅇ 치환(ㄱ: 수, ㄴ: 수):
    임시 = 배열[ㄱ]
    배열[ㄱ] = 배열[ㄴ]
    배열[ㄴ] = 임시

ㅎㅇ 파티셔닝(피봇: 수, 왼쪽: 수, 오른쪽: 수) 수:
    ㄱㄱ :
        ㄱㄱ :
            왼쪽 += 1
            ㅇㅈ? 배열[왼쪽] >= 배열[피봇]:
                ㅅㄱ
        ㄱㄱ :
            오른쪽 -= 1
            ㅇㅈ? 배열[오른쪽] <= 배열[피봇]:
                ㅅㄱ
        ㅇㅈ? 오른쪽 <= 왼쪽:
            치환(오른쪽, 피봇)
            ㅈㅈ 오른쪽
        치환(오른쪽, 왼쪽)


ㅎㅇ 퀵정렬(시작: 수, 끝: 수) :
    ㅇㅈ? 시작 + 1 >= 끝:
        ㅈㅈ

    피봇 = 파티셔닝(시작, 시작, 끝)

    퀵정렬(시작, 피봇)
    퀵정렬(피봇 + 1, 끝)

ㅎㅇ 시작() 수:
    ㄱㄱ 번호 = 0; 번호 < 배열크기; 번호 += 1:
        배열[번호] = rand()

    시작시간 = clock()

    퀵정렬(0, 배열크기)

    종료시간 = clock()

    ㄱㄱ 번호 = 0; 번호 < 배열크기; 번호 += 1:
        출(배열[번호])

    출((종료시간 - 시작시간), "ms")
```

## 알려진 문제:

**윈도우 CP949 지원 문제**

윈도우 명령 프롬프트의 한글 인코딩(CP949)과 일반적인 파일 인코딩(UTF-8)이 맞지 않아
파일 경로 탐색, 에러 메시지 출력, 구문 분석의 인코딩이 모두 달라지는 문제가 있습니다.

*줄랭 컴파일러는 모든 인코딩을 UTF-8로 강제합니다.*

따라서 실행 전에 터미널에서 "chcp 65001" 을 실행해 터미널 인코딩을 UTF-8로 바꿔주어야 합니다. 
또는 윈도우 시스템 로켈을 UTF-8로 설정해 인코딩을 UTF-8로 통일해주어야지 정상적으로 작동합니다.

IDE를 사용 중이라면 IDE 콘솔 인코딩을 UTF-8로 바꾸면 됩니다.

**배열 및 포인터 지원 문제**

줄랭 컴파일러의 타입 시스템은 굉장히 단순하게 이루어져 있고, 구조상 배열과 포인터를 처리하기가 매우 어렵습니다.
또한 원시 포인터를 그대로 도입하지 않고, 포인터를 안전하게 사용할 수 있는 도구들을 추가하려 하기 때문에, 배열 및 포인터에 대한 지원은 꽤 오랜 시간 후에 가능할 것 같습니다.


**에러 회복 문제**

컴파일 과정에서 한 번 틀린 문법이 오게 되면, 토큰 처리 순서가 깨지면서 그 뒤의 모든 구문을 에러로 처리하는 문제가 있습니다.
보통은 한 줄 내에 회복이 되지만, 운이 나쁘다면 함수 전체 또는 파일 전체가 에러로 뒤덮힐 수도 있습니다.

에러가 생긴 순간 컴파일을 중단해버리면 에러 메시지가 너무 많이 출력되는 문제는 해결되지만, 에러를 보기 위해 여러 번 컴파일하고 고쳐야 한다는 문제가 다시 생깁니다.

줄랭 컴파일러의 파서는 재귀 하향식으로 구현되어 있는데, 정보를 모두 함수 리턴값으로 전달하다 보니 전달할 정보를 추가하기가 쉽지 않은 상황입니다.

만약 에러 메시지가 너무 많이 출력된다면, 맨 위의 에러가 그 원인이므로 첫 번째 에러부터 고쳐주세요.

## 줄랭 컴파일러

줄랭 컴파일러는 줄랭을 LLVM IR코드로 (zul to ll) 변환하는 컴파일러 프론트엔드입니다. JIT기능을 내장하고 있어
코드를 즉시 실행할 수 있고, IR코드를 파일로 내보내서 네이티브 바이너리로도 컴파일이 가능합니다.

만약 바이너리 실행 파일을 얻고 싶다면 줄랭 컴파일러에 적절한 옵션을 넣어 IR 코드 또는 비트코드로 컴파일하고, 이를 clang에 넘겨주면 됩니다.
llc, lld 등을 이용하는 방법이 있지만, clang을 이용하는 것이 가장 편리합니다.

아직 JIT Optimization이 지원되지 않기 때문에 정말 빠른 프로그램을 원한다면 위의 방법을 이용해주세요. 
clang에 Optimization옵션을 넣어주면 됩니다. (JIT도 충분히 빠르긴 합니다)

컴파일러 옵션은 아래와 같습니다. (아무 옵션도 넣지 않으면 JIT로 실행합니다)

- zul [옵션] <줄랭 소스파일>


- --help : 커맨드 라인 옵션 도움말
- --version : 줄랭 컴파일러 버전
- -S : IR코드로 컴파일 (.ll 파일로 컴파일)
- -c : bitcode로 컴파일 (.bc로 컴파일)
- -o : 아웃풋 파일 이름 (-S 또는 -c 옵션을 주었을 때)

컴파일러의 자세한 동작 원리와 구조는 [줄랭 컴파일러 구조](./zullang_TMI.md#줄랭-컴파일러-구조)를 참고하세요

## 문법 지원 현황

| 문법                    | 상태          |
|-----------------------|-------------|
| 산술 연산                 | 지원          |
| 논리 연산                 | 지원          |
| 지역 변수                 | 지원          |
| 전역 변수                 | 지원          |
| 단락 평가 (short-circuit) | 지원          |
| ㅈㅈ문                   | 지원          |
| ㄱㄱ문                   | 지원          |
| ㅌㅌ문                   | 지원          |
| ㅅㄱ문                   | 지원          |
| ㅇㅈ문                   | 지원          |
| 전역 변수 초기화             | 지원          |
| 암시적 형변환               | 지원          |
| 명시적 형변환               | 지원 예정       |
| 함수                    | 지원          |
| 함수 반환 타입 추론           | 지원 예정       |
| 배열                    | 지원 (전역 변수만) |
| 함수 오버로딩               | 지원 예정       |
| 연산자 오버로딩              | 지원 예정       |
| 참조자                   | 지원 예정       |
| 포인터                   | 미정          |
| 클래스                   | 지원 예정       |
| 동적 할당                 | 미정          |
| 삼항 연산자                | 미정          |
| static, const         | 미정          |
| 리터럴 배열                | 지원 예정       |
| 리터럴 셋                 | 지원 예정       |
| 리터럴 맵                 | 지원 예정       |

## 참고 자료

[My First Language Frontend with LLVM Tutorial](https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html)

[A Complete Guide to LLVM for Programming Language Creators](https://mukulrathi.com/create-your-own-programming-language/llvm-ir-cpp-api-tutorial/)

